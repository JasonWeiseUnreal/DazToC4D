// DAZ Studio version 4.12.0.86 filetype DAZ Script

(function(){
	
	var s_oFileInfo = new DzFileInfo( getScriptFileName() );
	var s_sToolName = s_oFileInfo.baseName();
	s_oFileInfo.deleteLater();
	
	var s_aSkeletons = Scene.getSkeletonList();
	var s_oPrimarySkeleton = s_aSkeletons.length > 0 ? s_aSkeletons[0] : undefined;
	
	var s_sMorphRules = "";
	var s_aMorphExported = [];
	
	var s_oMorphs = {};
	var s_nLenName = 0;
	var s_nMaxName = 19;
	var s_nMaxAll = 63;
	var s_s3Spaces = "   ";
	var s_sAlf = "1234567890abcdefghijklmnopqrstuvwxyz";

	var s_sExporter = "DzFbxExporter";//"DzDAZCOLLADAExporter"
	var s_sExportExt = "fbx";//"dae"
	var s_sRootPath = "";
	var s_sExports = "DazToC4D";
	

	// --- START node_properties ----
	/**********************************************************************
	
		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:
	
		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0
	
	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/properties/node_properties/start
 	
 	// - Extraccted functions
 	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting a list of the properties in a group
	function getGroupProperties( oGroup, bTraverse, bRecurse )
	{
		// Declare an array to hold properties
		var aProperties = [];
		
		// If a group is not passed in
		if( !oGroup ){
			// We are done, return an empty array
			return aProperties;
		}
		
		// Get the number of proeprties in the group
		var nProperties = oGroup.getNumProperties();
		// Pre-size the properties array
		aProperties = new Array( nProperties );
		// Iterate over the properties, setting each element in the array
		for( var i = 0; i < nProperties; i += 1 ){
			// Assign the property to the position in the array
			aProperties[ i ] = oGroup.getProperty( i );
		}
		
		// If we are recursing
		if( bRecurse ){
			// Concatenate the properties array from child groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getFirstChild(), true, bRecurse ) );
		}
		
		// If we are traversing
		if( bTraverse ){
			// Concatenate the properties array from sibling groups
			aProperties = aProperties.concat(
				getGroupProperties( oGroup.getNextSibling(), bTraverse, bRecurse ) );
		}
 		
		// Return the array of properties
		return aProperties;
	};
	
	/*********************************************************************/
	// Array<DzProperty> : A function for getting the list properties for an element
	function getElementProperties( oElement, bTraverse, bRecurse )
	{
		// Get the property group tree for the element
		var oPropertyGroupTree = oElement.getPropertyGroups();
		
		// If the application version is 4.9.4.101 or newer and we want all properties
		if( App.version64 >= 0x0004000900040065 && bTraverse && bRecurse ){
			// Return the properties for the element
			return oPropertyGroupTree.getAllProperties();
		}
		
		// Get the first group in the tree
		var oPropertyGroup = oPropertyGroupTree.getFirstChild();
		// Return the properties for the element
		return getGroupProperties( oPropertyGroup, bTraverse, bRecurse );
	};
	
// --- END node_properties ----
	
	
	// --- START convert_figure_to_props ----
	/**********************************************************************

		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:

		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0

	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/nodes/convert_figure_to_props/start
	
	// - Modified to remove display of messages presented to the user
	/*********************************************************************/

	function convert2Prop( oSelectedNode )
	{
		// If the selected node is a bone
		if( oSelectedNode.inherits( "DzBone" ) ){
			// Get the skeleton
			oSelectedNode = oSelectedNode.getSkeleton();
		}
		
		// If we don't have a skeleton
		if( !oSelectedNode.inherits( "DzSkeleton" ) ){
			return;
		}
		
		// Provide busy feedback to the user
		setBusyCursor();
		
		// Declare working variables
		var oNode, oParent;
		
		// Get the number of followers for the skeleton
		var nFollowers = oSelectedNode.getNumFollowSkeletons();
		// Presize an array to collect the converted nodes
		var aProps = new Array( nFollowers );
		
		// Iterate over the followers; reverse order,
		// the list will change with each conversion
		for( var i = nFollowers - 1; i >= 0; i -= 1 ){
			// Get the 'current' follower
			oNode = oSelectedNode.getFollowSkeleton( i );
			// Get the parent of the follower
			oParent = oNode.getNodeParent();
			// If we have a parent
			if( oParent ){
				// Unparent the follower, in place
				oParent.removeNodeChild( oNode, true );
			}
			
			// Convert the follower to a prop and collect it
			aProps[ i ] = oSelectedNode.convertFigureToProp( oNode, oNode.name );
		}
		
		// Create an array helper; to improve speed of resizing the array
		var oArrayHelper = new DzArrayHelper();
		
		// Get all of the child nodes of the figure
		var aNodes = oSelectedNode.getNodeChildren( true );
		
		// Iterate over the skeleton nodes
		for( var i = 0; i < aNodes.length; i += 1 ){
			oNode = aNodes[ i ];
			// If the node is not a bone; its some sort of 'prop'
			if( !oNode.inherits( "DzBone" ) ){
				// Get the parent of the node
				oParent = oNode.getNodeParent();
				// If we have a parent
				if( oParent ){
					// Unparent the prop, in place
					oParent.removeNodeChild( oNode, true );
					// Add the prop to the list
					aProps = oArrayHelper.addToArray( aProps, oNode );
				}
			}
		}
		
		// Convert the figure to a prop
		oSelectedNode = oSelectedNode.convertFigureToProp( oSelectedNode, oSelectedNode.name );
		
		// Iterate over the props
		for( var i = 0; i < aProps.length; i += 1 ){
			// Get the 'current' prop
			oNode = aProps[ i ];
			// Parent the prop to the figure, in place
			oSelectedNode.addNodeChild( oNode, true );
		}
		
		// Update the user
		clearBusyCursor();
	};
	
	// --- END convert_figure_to_props ----
	/*********************************************************************/

	// --- START replaceInstance ----
	// Adapted: https://www.daz3d.com/forums/discussion/comment/4940501/#Comment_4940501
	/*********************************************************************/

	function doAction( sClassName  )
	{
		var oMgr = MainWindow.getActionMgr();
		var oAction = oMgr.findAction( sClassName  );
		if( !oAction ){
			return;
		}
		
		oAction.trigger();
	};

	/*********************************************************************/
	function replaceInstance( oInstance, oNode )
	{
		var oParent = oInstance.getNodeParent();
		Scene.selectAllNodes( false );
		
		oInstance.select( true );
		doAction( "DzCopyNodeAction" );
		oInstance.select( false );
		
		var aNodes = Scene.getNodeList();
		var nNodes = aNodes.length;
		
		oNode.select( true );
		//doAction( "DzDuplicateNodeHierarchyAction" );
		doAction( "DzDuplicateNodeAction" );
		oNode.select( false );
		
		aNodes = Scene.getNodeList();
		var oReplacement = aNodes[nNodes];
		
		if( oParent ){
			oParent.addNodeChild( oReplacement );
		}
		
		oReplacement.select( true );
		doAction( "DzPasteNodeAction" );
		oReplacement.select( false );
		
		var oControl = oReplacement.getScaleControl();
		if( oControl.getValue() == 0 ){
			oControl.setValue( 1 );
		}
		
		oControl = oReplacement.getXScaleControl();
		if( oControl.getValue() == 0 ){
			oControl.setValue( 1 );
		}
		
		oControl = oReplacement.getYScaleControl();
		if( oControl.getValue() == 0 ){
			oControl.setValue( 1 );
		}
		
		oControl = oReplacement.getZScaleControl();
		if( oControl.getValue() == 0 ){
			oControl.setValue( 1 );
		}
		
		Scene.removeNode( oInstance );
	};
	
	// --- END replaceInstance ----
	/*********************************************************************/
	function replaceInstanceAll()
	{
		var oNode;
		var nNodes = Scene.getNumNodes();
		var aInstances = new Array( nNodes );
		for( var i = 0; i < nNodes; i += 1 ){
			oNode = Scene.getNode( i );
			if( oNode.inherits( "DzInstanceNode" ) ){
				//replace( oNode, oNode.getTarget() );
				//debug( oNode.getLabel() + ":" + oNode.getTarget().getLabel() );
				aInstances[i] = oNode;
			}
		}
		
		aInstances = aInstances.filter( Boolean );
		
		if( aInstances.length > 0 ){
			var nResult = MessageBox.question(
				qsTr( "Instances found. They need to be replaced before export. Replace them?" ),
				s_sToolName, qsTr( "&Yes" ), qsTr( "&No" )
				);
			if( nResult == 0 ){
				//debug( "yes" );
				for( var i = 0; i < aInstances.length; i += 1 ){
					oNode = aInstances[i];
					//debug( oNode.getLabel() + ":" + oNode.getTarget().getLabel() );
					try {
						replaceInstance( oNode, oNode.getTarget() );
					}
					catch( error ){}
				}
			}
		}
	};
	
	// --- START export_fbx_silent ----
	/**********************************************************************

		The following is derived from a work published as part of the
		Daz Script Documentation. This portion of the script, and/or any
		portion thereof, may only be used in accordance with the
		following license:

		Creative Commons Attribution 3.0 Unported (CC BY 3.0)
		- http://creativecommons.org/licenses/by/3.0

	**********************************************************************/
	// Source: http://docs.daz3d.com/doku.php/public/software/dazstudio/4/referenceguide/scripting/api_reference/samples/file_io/export_fbx_silent/start
	
	// - Modified to support switching exporters
	// - Other changes for this specific use case
	/*********************************************************************/

	function exportScene( sClassName, sPath, sBaseName, sExt )
	{
		// Get the export manager
		var oExportMgr = App.getExportMgr();
		// Find the exporter
		var oExporter = oExportMgr.findExporterByClassName( sClassName );
		// If the exporter exists
		if( oExporter ){
			// Create a settings object
			var oSettings = new DzFileIOSettings();
			
			// Define whether or not to show options
			var bShowOptions = false;
			
			// Define whether or not to show options before prompting for a path;
			// requires 4.9.3.22 or later
			var bOptionsBeforeFile = (bShowOptions && App.version64 >= 0x0004000900030016);
			
			// Get the options for the exporter
			if( !oExporter.getOptions( oSettings, bShowOptions && bOptionsBeforeFile, "" ) ){
				// We're done...
				return;
			}
			
			if( sClassName == "DzFbxExporter" ){
				// Selected
				oSettings.setBoolValue( "doSelected", false );
				// No Hidden
				oSettings.setBoolValue( "doVisible", false );
				// Figures
				oSettings.setBoolValue( "doFigures", true );
				// Props
				oSettings.setBoolValue( "doProps", true );
				// Lights
				oSettings.setBoolValue( "doLights", true );
				// Cameras
				oSettings.setBoolValue( "doCameras", true );
				// Animations
				oSettings.setBoolValue( "doAnims", false );
				// Morphs
				oSettings.setBoolValue( "doMorphs", true );
				
				// Morph Rules
				// Format for rules is "Match1\nAction1\nMatch2\nAction2\nMatch3\nAction3",
				// where Match# is a string to search for and Action# is one of Bake|Export|Ignore
				// The names of the morphs are in the form: node_name.parameter_name
				// The default action is to Bake
				// So "FBMHeavy\nExport\nThin\nExport" would export all morphs that have FBMHeavy and all morphs that have Thin in the name
				//Hard Code Fix added to Deal with Support for new face morphs
				oSettings.setStringValue( "rules", s_sMorphRules);
				
				// Format
				// Format for format is "Year# -- Type",
				// where Year# is one of 2006|2009|2010|2011|2012|2013|2014 and
				// Type is one of Ascii|Binary
				oSettings.setStringValue( "format", "FBX 2012 -- Binary" );
				
				// Embed Textures
				oSettings.setBoolValue( "doEmbed", true );
				// Collect Textures To Folder
				oSettings.setBoolValue( "doCopyTextures", false );
				// Merge Diffuse and Opacity Textures
				oSettings.setBoolValue( "doDiffuseOpacity", false );
				// Merge Clothing Into Figure Skeleton
				oSettings.setBoolValue( "doMergeClothing", true );
				// Convert Clothing to Static Geometry
				oSettings.setBoolValue( "doStaticClothing", false );
				// Allow Degraded Skinning
				oSettings.setBoolValue( "degradedSkinning", true );
				// Allow Degraded Scaling
				oSettings.setBoolValue( "degradedScaling", true );
				// SubD Information
				oSettings.setBoolValue( "doSubD", false );
				// Collapse UV Tiles
				oSettings.setBoolValue( "doCollapseUVTiles", false );
			} else if( sClassName == "DzDAZCOLLADAExporter" ){
				/*
				oSettings.setIntValue( "ExportProfile", 0 );
				oSettings.setBoolValue( "RemoveUnusedVerts", true );
				oSettings.setBoolValue( "IgnoreInvisibleNodes", false );
				oSettings.setBoolValue( "BakeScale", false );
				oSettings.setBoolValue( "MergeFollowingSkeletons", false );
				oSettings.setBoolValue( "SparseMorphs", true );
				oSettings.setBoolValue( "WeldGeometry", false );
				oSettings.setBoolValue( "UseModifierLists", true );
				oSettings.setBoolValue( "CombineMorphs", true );
				oSettings.setStringValue( "ImageCopyPath", "" );
				oSettings.setBoolValue( "CopyImagesToFolder", false );
				oSettings.setBoolValue( "InvertAlphaImage", false );
				oSettings.setBoolValue( "CombineAlphaImageIntoDiffuse", false );
				oSettings.setStringValue( "CombineAlphaImageIntoDiffuseExt", "png" );
				oSettings.setBoolValue( "MergeMaterials", false );
				oSettings.setBoolValue( "ExportAnimations", false );
				oSettings.setBoolValue( "AnimationIncludesTransformations", false );
				oSettings.setBoolValue( "AnimationsIncludeMorphs", false );
				*/
			}
			
			// If the version is 4.9.3.22 or newer
			if( App.version64 >= 0x0004000900030016 ){
				// Define whether or not to show the options after prompting for a file;
				// prior to 4.9.3.22 this exporter ignored this option entirely,
				// running silent was implied by virtue of being run via script
				oSettings.setIntValue( "RunSilent", (bShowOptions && !bOptionsBeforeFile ? 0 : 1) );
			}
			
			// Debug
			//print( oSettings.toJsonString() );
			
			// Ensure the path exists
			var oDir = new DzDir( sPath );
			oDir.mkdir( sPath );
			
			// Write the file using the options specified
			oExporter.writeFile(
				String( "%1/%2.%3" ).arg( sPath ).arg( sBaseName ).arg( sExt ),
				oSettings );
			//print( oSettings.toJsonString() );
			
			// Clean up; don't leak memory
			oExporter.deleteLater();
		// We didn't find an exporter with the class name we wanted
		} else {
			// Inform the user
			MessageBox.critical( qsTr("An exporter with the class name \"%1\" " +
				"could not be found.").arg( sClassName ),
				qsTr("Critical Error"), qsTr("&OK") );
		}
	};
	
	// --- END export_fbx_silent ----
	/*********************************************************************/

	// Number : ...
	function getXRot( sBoneLabel )
	{
		if( !s_oPrimarySkeleton || sBoneLabel.isEmpty() ){
			return undefined;
		}
		
		var oBone = s_oPrimarySkeleton.findBoneByLabel( sBoneLabel );
		if( !oBone ){
			return undefined;
		}
		
		var oControl = oBone.getXRotControl();
		var nValue = oControl.getValue();
		//print( ":: get x :: " + sBoneLabel + " :: " + nValue );
		return nValue;
	};
	
	/*********************************************************************/
	// void : ...
	function setXRot( sBoneLabel, nValue )
	{
		if( !s_oPrimarySkeleton
			|| sBoneLabel.isEmpty()
			|| nValue == undefined ){
			return;
		}
		
		//print( ":: set x :: " + sBoneLabel + " :: " + nValue );
		var oBone = s_oPrimarySkeleton.findBoneByLabel( sBoneLabel );
		if( !oBone ){
			return;
		}
		
		var oControl = oBone.getXRotControl();
		oControl.setValue( nValue );
	};

	/*********************************************************************/
	// void : ...
	// Note: destructive - modifies the scene contents
	// TODO: Redo Morph export need to give users a choice
	function buildMorphList( oNode )
	{
		if( oNode.inherits( "DzFigure" ) ){
            oNode = oNode.getSkeleton();
			var aProperties = getElementProperties( oNode, true, true );
        }    
		else{
			var aProperties = getElementProperties( oNode, true, true );
		}
		var nAlfIdx = 0;
		var aTops = [ "Morphs", "Hidden", "Pose" ];
		
		var oProp;
		var oOwner;
		var oTop;
		var sPath;
		var sHead;
		var sLabel;
		var sTmp;
		
		for( var i = 0; i < aProperties.length; i += 1 ){
			oProp = aProperties[i];
			oOwner = oProp.getOwner();
			sPath = oProp.getPath();
			sHead = "";

			for( var j = 0; j < aTops.length; j += 1 ){
				oTop = aTops[j];
				if( sPath.indexOf( "/" + oTop ) == 0 ){
					sHead = "<" + oTop + ">";
					break;
				}
			}
			
			if( sHead.isEmpty() ){
				continue;
			}
			
			sLabel = oProp.getLabel();
			if( ( sLabel.length + 2 + s_nMaxName ) > s_nMaxAll ){
				sLabel = sLabel.slice( 0, s_nMaxAll - s_nMaxName - 2 - 2 );
				sLabel = sLabel + "_" + s_sAlf.substr( nAlfIdx, 1 );
				nAlfIdx += 1;
				nAlfIdx = nAlfIdx % 36;
			}
			
			sName = oProp.getName()
			// To deal with Hidden Morphs
			if (sHead.indexOf("Hidden") > 0){
				sName = sLabel
			};
			s_oMorphs[sLabel] = {
									"sMorphHead": sHead,
									"sMorphName" : sName,
									"sMorphPath" : sPath
								};
			
		}
	};

	/*********************************************************************/
	// Array<String> : ...
	// TODO: Only export base Morphs 
	function getMinimalMorphRules()
	{
		var sResult; 

		for( sMorphLabel in s_oMorphs ){
			var sMorphPath = s_oMorphs[sMorphLabel]['sMorphPath']
			var sMorphName = s_oMorphs[sMorphLabel]['sMorphName']
			var sMorphHead = s_oMorphs[sMorphLabel]['sMorphHead']
			

			if( sMorphPath.indexOf( '/Head' ) > 0 ){
				if( sMorphPath.endsWith( 'Expressions' ) ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}
				if( sMorphPath.indexOf( '/Expressions' ) < 0 ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}
			}
			if ( sMorphPath.indexOf( 'Corrective' ) > 0 ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}
		}
		
		return sResult;
	};
	
	/*********************************************************************/
	// Array<String> : ...
	// TODO: Add better customization for Presets
	function getMorphPresets( sPreset )
	{
		var sResult 

		for( sMorphLabel in s_oMorphs ){
			var sMorphPath = s_oMorphs[sMorphLabel]['sMorphPath']
			var sMorphName = s_oMorphs[sMorphLabel]['sMorphName']
			var sMorphHead = s_oMorphs[sMorphLabel]['sMorphHead']
			if ( sPreset == "All Body Morphs" ){
				if ( sMorphPath.indexOf( '/Arms' ) > 0
					|| sMorphPath.indexOf( '/Hip' ) > 0
					|| sMorphPath.indexOf( '/Torso' ) > 0
					|| sMorphPath.indexOf( '/Neck' ) > 0
					|| sMorphPath.indexOf( '/Legs' ) > 0
					|| sMorphPath.indexOf( '/Hands' ) > 0
					|| sMorphPath.indexOf( '/Feet' ) > 0 ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}		
			}
			if ( sPreset == "All Joint Corrective Morphs" ){
				if ( sMorphPath.indexOf( 'Corrective' ) > 0 ){
					sResult += sMorphName + "\n1\n";
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}
			}
				
			else{
				if ( sMorphPath.indexOf( '/Head' ) > 0 ){
					if ( sPreset == "Face Controls" ){
						if(!( sMorphPath.indexOf( 'Expressions' ) > 0 
							|| sMorphPath.indexOf( 'Visemes' ) > 0 ) ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( [sMorphName ,sMorphLabel] );
						}
					}
					if ( sPreset == "Expressions" ){
						if( sMorphPath.indexOf( 'Expressions' ) > 0 ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( [sMorphName ,sMorphLabel] );
						}
					}
					if ( sPreset == "Visemes" ){
						if	( sMorphPath.indexOf( 'Visemes' ) > 0 ){
							sResult += sMorphName + "\n1\n";
							s_aMorphExported.push( [sMorphName ,sMorphLabel] );
						}
					}		
				}
			}
		}
		
		return sResult;
	};

	/*********************************************************************/
	
	// Boolean : ...
	// TODO: Replace a listbox for a more functional option, Allow user to Choose From Their Expressions
	function promptMorphRules( oNode )
	{	
		
		var wDlg = new DzBasicDialog();
		wDlg.caption = s_sToolName + ": Morph Names";
	
		var sKey = wDlg.caption.replace( / /g, "" ) + "Dlg";
		
		if( oNode ){
			wDlg.caption += " - " + oNode.getLabel();
		}
		
		var oDlgWgt = wDlg.getWidget();
		oDlgWgt.objectName = sKey;
		
		//addBanner( wDlg, App.getResourcesPath() + "/images/bridges/" + s_sToolName + ".png" );
		
		var wMinimalMorphsCbx = new DzCheckBox( wDlg );
		wMinimalMorphsCbx.text = qsTr( "Include All Default Head and Joint Corrective Morphs" );
		wMinimalMorphsCbx.checked = true;
		wDlg.addWidget( wMinimalMorphsCbx );
		
		var wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wMorphNamesLbl = new DzLabel( wDlg );
		wMorphNamesLbl.text = qsTr( "Morph Names: (line separated)\n[empty = OK, partial words = OK, 3+ letters required]" );
		wDlg.addWidget( wMorphNamesLbl );
		
		var wMorphNamesTEdit = new DzTextEdit( wDlg );
		wMorphNamesTEdit.text = "";
		wDlg.addWidget( wMorphNamesTEdit );
		
		wLbl = new DzLabel( wDlg );
		wDlg.addWidget( wLbl );
		
		var wValidMorphNamesLbl = new DzLabel( wDlg );
		wValidMorphNamesLbl.text = qsTr( "Valid Morph Names and Presets:\n[double-click to copy above]" );
		wDlg.addWidget( wValidMorphNamesLbl );

		var aMorphList = []
		var wValidMorphNamesLBox = new DzListBox( wDlg );
		var sMorphHead;
		var sMorphPath;

		for(var s_aMorphLabel in s_oMorphs) {
			sMorphHead = s_oMorphs[s_aMorphLabel]["sMorphHead"];
			sMorphPath = s_oMorphs[s_aMorphLabel]["sMorphPath"];
			if( sMorphHead != "Hidden" ){
				var sMorphHeaders = sMorphPath.split("/") 
				aMorphList.push( 
									sMorphHeaders[sMorphHeaders.length - 2] + " "
									+ sMorphHeaders[sMorphHeaders.length - 1] + " :"
									+ s_s3Spaces + s_aMorphLabel
								);
			}
		}

		// Organize the Visible Morphs
		aMorphList.sort()

		for( var sMorphLabel in s_oMorphs ){
			sMorphHead = s_oMorphs[sMorphLabel]["sMorphHead"];
			if( sMorphHead == "Hidden" ){
				aMorphList.push( sMorphHead + ":" + s_s3Spaces + sMorphLabel );
			}
		}

		// Add a few temporary presets for ease of use.	
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Face Controls" );
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Expressions" );
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"Visemes" );	
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"All Body Morphs" );
		wValidMorphNamesLBox.insertItem( "Presets:" + s_s3Spaces +"All Joint Corrective Morphs" );
		
		for( var i = 0; i < aMorphList.length; i += 1 ){
			wValidMorphNamesLBox.insertItem( aMorphList[i] );
		}
		wDlg.addWidget( wValidMorphNamesLBox );
		
		function addValidMorphName(){
			var sCurText = wValidMorphNamesLBox.currentText;
			sCurText = sCurText.split( ":" + s_s3Spaces )[1];
			wMorphNamesTEdit.append( sCurText );
		};
		wValidMorphNamesLBox.doubleClicked.connect( wValidMorphNamesLBox, addValidMorphName );
		
		var sizeHint = oDlgWgt.minimumSizeHint;
		var nHeight = sizeHint.height;
		var nWidth = sizeHint.width < 300 ? 300 : sizeHint.width;
		wDlg.setFixedSize( nWidth, sizeHint.height * 2 );
		
		if( !wDlg.exec() ){
			return false;
		}
		
		if( wMinimalMorphsCbx.checked ){
			s_sMorphRules = getMinimalMorphRules();
		}
		
		createMorphRules( wMorphNamesTEdit.text.split( "\n" ) );
	
		return true;
	};

	/*********************************************************************/
	// Take List of Morph Labels and Convert to Format for FBX Exporter
	// void : ...
	// TODO: Allow Partial Names to Export Morphs, Refactor Code to Grab Morph Info Cleaner
	function createMorphRules( aMorphLabels )
	{	
		var sMorphName;
		var sMorphLabel;
		
		// To do find a better way to stop if nothing is chosen
		if ( aMorphLabels !==undefined ){
			for( var i = 0; i < aMorphLabels.length; i += 1 ){	
				sMorphLabel = aMorphLabels[i];
				
				if ( s_oMorphs[sMorphLabel] !== undefined ){

					if (s_oMorphs[sMorphLabel]["sMorphHead"] == 'Pose' ){
					sMorphName = s_oMorphs[sMorphLabel]["sMorphName"];
					}
					else{
						//Hidden Morphs do not have labels
						sMorphName = sMorphLabel;
					}
					s_aMorphExported.push( [sMorphName ,sMorphLabel] );
				}
				else{
					s_sMorphRules += getMorphPresets( sMorphLabel );
					}
				s_sMorphRules += sMorphName + "\n1\n";
				
			}
		}
		s_sMorphRules += "Anything\n0";

		return true;
	};

	/*********************************************************************/

	// void : ...
	function heelsFix( oSkeleton )
	{
		if( oSkeleton ){
			return;
		}
		
		//Left
		try { var xRotLeftMetatarsals = getXRot( "Left Metatarsals" ); } catch( error ){}
		try { var xRotLeftHeel = getXRot( "Left Heel" ); } catch( error ){}
		try { var xRotLeftFoot = getXRot( "Left Foot" ); } catch( error ){}
		try { var xRotLeftToes = getXRot( "Left Toes" ); } catch( error ){}
		try { var xRotLeftBigToe = getXRot( "Left Big Toe" ); } catch( error ){}
		try { var xRotLeftBigToe2 = getXRot( "Left Big Toe_2" ); } catch( error ){}
		try { var xRotLeftSmallToe1 = getXRot( "Left Small Toe 1" ); } catch( error ){}
		try { var xRotLeftSmallToe12 = getXRot( "Left Small Toe 1_2" ); } catch( error ){}
		try { var xRotLeftSmallToe2 = getXRot( "Left Small Toe 2" ); } catch( error ){}
		try { var xRotLeftSmallToe22 = getXRot( "Left Small Toe 2_2" ); } catch( error ){}
		try { var xRotLeftSmallToe3 = getXRot( "Left Small Toe 3" ); } catch( error ){}
		try { var xRotLeftSmallToe32 = getXRot( "Left Small Toe 3_2" ); } catch( error ){}
		try { var xRotLeftSmallToe4 = getXRot( "Left Small Toe 4" ); } catch( error ){}
		try { var xRotLeftSmallToe42 = getXRot( "Left Small Toe 4_2" ); } catch( error ){}
		
		//Right
		try { var xRotRightMetatarsals = getXRot( "Right Metatarsals" ); } catch( error ){}
		try { var xRotRightHeel = getXRot( "Right Heel" ); } catch( error ){}
		try { var xRotRightFoot = getXRot( "Right Foot" ); } catch( error ){}
		try { var xRotRightToes = getXRot( "Right Toes" ); } catch( error ){}
		try { var xRotRightBigToe = getXRot( "Right Big Toe" ); } catch( error ){}
		try { var xRotRightBigToe2 = getXRot( "Right Big Toe_2" ); } catch( error ){}
		try { var xRotRightSmallToe1 = getXRot( "Right Small Toe 1" ); } catch( error ){}
		try { var xRotRightSmallToe12 = getXRot( "Right Small Toe 1_2" ); } catch( error ){}
		try { var xRotRightSmallToe2 = getXRot( "Right Small Toe 2" ); } catch( error ){}
		try { var xRotRightSmallToe22 = getXRot( "Right Small Toe 2_2" ); } catch( error ){}
		try { var xRotRightSmallToe3 = getXRot( "Right Small Toe 3" ); } catch( error ){}
		try { var xRotRightSmallToe32 = getXRot( "Right Small Toe 3_2" ); } catch( error ){}
		try { var xRotRightSmallToe4 = getXRot( "Right Small Toe 4" ); } catch( error ){}
		try { var xRotRightSmallToe42 = getXRot( "Right Small Toe 4_2" ); } catch( error ){}
		
		Scene.selectAllNodes( false );
		
		oSkeleton.select( true );
		
		var oMgr = MainWindow.getActionMgr();
		var oAction = oMgr.findAction( "DzRestoreFigurePoseAction" );
		if( oAction ){
			oAction.trigger();
		}
		
		var nZero = 0;
		
		//Left
		//print( "-----------------------------------------" );
		try { setXRot( "Left Metatarsals", xRotLeftMetatarsals ); } catch( error ){}
		try { setXRot( "Left Heel", nZero ); } catch( error ){}
		//try { setXRot( "Left Foot", xRotLeftFoot ); } catch( error ){}
		try { setXRot( "Left Toes", xRotLeftToes ); } catch( error ){}
		try { setXRot( "Left Big Toe", xRotLeftBigToe ); } catch( error ){}
		try { setXRot( "Left Big Toe_2", xRotLeftBigToe2 ); } catch( error ){}
		try { setXRot( "Left Small Toe 1", xRotLeftSmallToe1 ); } catch( error ){}
		try { setXRot( "Left Small Toe 1_2", xRotLeftSmallToe12 ); } catch( error ){}
		try { setXRot( "Left Small Toe 2", xRotLeftSmallToe2 ); } catch( error ){}
		try { setXRot( "Left Small Toe 2_2", xRotLeftSmallToe22 ); } catch( error ){}
		try { setXRot( "Left Small Toe 3", xRotLeftSmallToe3 ); } catch( error ){}
		try { setXRot( "Left Small Toe 3_2", xRotLeftSmallToe32 ); } catch( error ){}
		try { setXRot( "Left Small Toe 4", xRotLeftSmallToe4 ); } catch( error ){}
		try { setXRot( "Left Small Toe 4_2", xRotLeftSmallToe42 ); } catch( error ){}
		
		//Right
		//print( "-----------------------------------------" );
		try { setXRot( "Right Metatarsals", xRotRightMetatarsals ); } catch( error ){}
		try { setXRot( "Right Heel", nZero ); } catch( error ){}
		//try { setXRot( "Right Foot", xRotRightFoot ); } catch( error ){}
		try { setXRot( "Right Toes", xRotRightToes ); } catch( error ){}
		try { setXRot( "Right Big Toe", xRotRightBigToe ); } catch( error ){}
		try { setXRot( "Right Big Toe_2", xRotRightBigToe2 ); } catch( error ){}
		try { setXRot( "Right Small Toe 1", xRotRightSmallToe1 ); } catch( error ){}
		try { setXRot( "Right Small Toe 1_2", xRotRightSmallToe12 ); } catch( error ){}
		try { setXRot( "Right Small Toe 2", xRotRightSmallToe2 ); } catch( error ){}
		try { setXRot( "Right Small Toe 2_2", xRotRightSmallToe22 ); } catch( error ){}
		try { setXRot( "Right Small Toe 3", xRotRightSmallToe3 ); } catch( error ){}
		try { setXRot( "Right Small Toe 3_2", xRotRightSmallToe32 ); } catch( error ){}
		try { setXRot( "Right Small Toe 4", xRotRightSmallToe4 ); } catch( error ){}
		try { setXRot( "Right Small Toe 4_2", xRotRightSmallToe42 ); } catch( error ){}
		
		//print( "-----" );
	};
	
	// Number : ...
	function doesHavingSkeleton()
	{
		return Scene.getNumSkeletons() > 0;
	};

	/*********************************************************************/
	// Boolean : ...
	function doesHavingHip()
	{
		var oNode;
		for( var i = 0, n = Scene.getNumNodes(); i < n; i += 1 ){
			// Get the current node
			oNode = Scene.getNode( i );
			if( oNode.getName().toLowerCase() == "hip" ){
				return true;
			}
		}
		
		return false;
	};
	
	
	// void : ...
	// Delete previous export
	// Edited to Match Cinema 4D Current Export
	// TODO : refactor - efficiency
	function prepareForExport()
	{
		
		var oDir = new DzDir( "" );
		var sPath = oDir.homePath() + "/"
		s_sRootPath = sPath;
		
		var aFiles;
		var sDelPath;
		var oDelDir =  new DzDir( "" );
		
		var aSubs = [ "Documents", s_sExports];
		for( var i = 0; i < aSubs.length; i += 1 ){
			sPath = s_sRootPath + aSubs[i] + "/";
			oDir.setPath( sPath );
			if( !oDir.exists() ){
				oDir.mkdir( sPath );
			}
			
			if( i < 2 ){
				s_sRootPath = sPath;
			} else {
				oDir.setPath( sPath );
				
				aFiles = oDir.getFilesFromDir( [], true );
				for( var j = 0; j < aFiles.length; j += 1 ){
					oDir.remove( aFiles[j] );
				}
				
				for( var j = 0; j < 100; j += 1 ){
					sDelPath = sPath + "/" + aSubs[i] + j;
					oDelDir.setPath( sDelPath );
					if( oDelDir.exists() ){
						oDir.rmdir( sDelPath );
					} else {
						break;
					}
				}
			}
		}
	};

	/*********************************************************************/
	// SAVE maps to file... bump, specular, etc....
	// TODO: Replace with DTU
	// String : ...
	function label2Variable( sLabel )
	{
		var sLabelLwr = sLabel.toLowerCase();
		var sAlpha ='abcdefghijklmnopqrstuvwxyz0123456789_';
		var sResult = '';
		for( var i = 0; i < sLabelLwr.length; i += 1 ){
			if( sAlpha.search( sLabelLwr[i] ) >= 0 ){
				sResult += sLabel[i];
			}
			
			if( sLabelLwr[i] == ' ' ){
				sResult += '_';
			}
		}
		
		if( sResult == "Luminance_cdm^2" ){
			sResult = "Luminance_cdm_2";
		}
		
		return sResult;
	};

	/*********************************************************************/
	// String : ...
	function fixFilename( sFilename )
	{
		return sFilename.replace( "&", "(_)" );
	};

	/*********************************************************************/
	// String : ...
	function value2XMLString( oElement, sPropLabel )
	{
		try {
			var oProperty = oElement.findPropertyByLabel( sPropLabel );
			
			if( oProperty ){
				var sAttrib = label2Variable( sPropLabel );
				var sResult = '';
				var oTexture;
				
				//oElement.getName() == 'Walls' &&
				if( sPropLabel == 'Diffuse Texture' ){
					//debug( '12zzzzzzzzzzzzzzzzzzzzzzzzzzzzz ' + sPropLabel + ' ' + oProperty.getValue() );
					if( oProperty.inherits( "DzImageProperty" ) ){
						oTexture = oProperty.getValue();
						if( oTexture ){
							sResult += ' Diffuse_Color_Map="' + fixFilename( oTexture.getFilename() ) + '"';
						}
					}
				} else {
					if( oProperty.inherits( "DzNumericProperty" ) ){
						oTexture = oProperty.getMapValue();
						if( oTexture ){
							sResult = sAttrib + '_Map="' + fixFilename( oTexture.getFilename() ) + '"';
						}
					}
					
					if( oProperty.inherits( "DzColorProperty" ) ){
						var clrVal = oProperty.getColorValue();
						sResult += ' '+ sAttrib + '="Color ' + clrVal.red + ' ' + clrVal.green + ' ' + clrVal.blue + '"';
					} else {
						sResult += ' '+ sAttrib + '="'+ oProperty.getValue() + '"';
					}
				}
				
				return( sResult );
			}
		} catch( error ){
			return( '' );
		}
		
		return( '' );
	};

	/*********************************************************************/
	function savePropertiesToFile( sExporter, sExportPath, sExportBaseName, sExportExt )
	{
		var sFile = "%1/%2.xml".arg( sExportPath ).arg( sExportBaseName );
		
		var oConfigFile = new DzFile( sFile );
		oConfigFile.open( DzFile.WriteOnly );
		
		oConfigFile.writeLine( '<materials filename="%1.%2" >'.arg( sExportBaseName ).arg( sExportExt ) );
		
		var numI = Scene.getNumNodes();
		var numIMat;
		var numIShad;
		var oNode;
		var myTempObj;
		var myTempShape;
		var myWorkMat;
		var myWorkProperty;
		// Get the total number of scene nodes
		
		var listMat = new Array();
		// Iterate over each node
		var ii = 0;
		
		for( var i = 0; i < numI; i += 1 ){
			// Get the current node
			oNode = Scene.getNode( i );
			myTempObj = oNode.getObject();
			// does it have geometry?
			if( myTempObj != null ){
				myTempShape = myTempObj.getCurrentShape();
				// now digging for the materials!!
				numIMat = myTempShape.getNumMaterials();
				// iterating aaaagain
				for( var j = 0; j < numIMat; j += 1 ){
					myWorkMat = myTempShape.getMaterial( j );
					//debug( myWorkMat.getName() + ' - ' + myWorkMat.getNumProperties() );
					//var allMats = myWorkMat.getAllMaps();
					//var numMaps = allMats.length;
					var matName = myWorkMat.getName();
					var n = listMat.length;
					//listMat.pushIfNotExists( myTempObj.getName() + '-' + oNode.getLabel() + '-'+ matName );
					listMat.pushIfNotExists( myTempObj.getName() + '-' + matName );
					var n1 = listMat.length;
					if( n1 > n ){
						ii += 1;
						//debug( i + '/' + ii + '-' + myTempObj.getName() + '-' + matName );
						//debug( i + '/' + ii + '-' + oNode.getLabel() + '-' + matName );
						var matText = '    <material object="' + label2Variable( myTempObj.getName() ) + '" label="' + oNode.getLabel() + '" name="' + label2Variable( matName ) + '"';
						if( sExportExt == "fbx" ){
							matText = '    <material object="' + myTempObj.getName() + '.Shape" label="' + oNode.getLabel() + '" name="' + matName + '"';
						}
	
						var listAttr = new Array();
						for( var k = 0; k < myWorkMat.getNumProperties(); k += 1 ){
							var nn = listAttr.length;
							listAttr.pushIfNotExists( myWorkMat.getProperty( k ).getLabel() );
							var nn1 = listAttr.length;
							//debug( nn + '---' + nn1 + '---' + myWorkMat.getProperty( k ).getLabel() );
							if( nn1 > nn ){
								var temp = value2XMLString( myWorkMat, myWorkMat.getProperty( k ).getLabel() );
								if( temp != '' ){
									matText += ' ' + temp;
								}
							}
							//debug( i + ' ' + myWorkMat.getProperty( i ).getLabel() + ' - ' + myWorkMat.getProperty( i ).getPath() );
						}
						matText += '/>';
						oConfigFile.writeLine( matText );
					}
				}
			}
			//the second iteration is ended above
		}
		oConfigFile.writeLine( '</materials>' );
		oConfigFile.close();
	};

	/*********************************************************************/	
	// void : ...
	// Note: Configure DTU File
	// TO DO: Grab Subdivision info and Morphs Exporting
	function writeConfiguration( oNode, sFilename )
	{
		var sDtufilename = sFilename + ".dtu";
		var oDtufile = new DzFile( sDtufilename );
		var oDtuJson = {};
		var aChildren = oNode.getNodeChildren( true );
		var nChildren = aChildren.length;
		
		oDtuJson["Asset Name"] = oNode.getLabel();
		oDtuJson["Materials"] = [];
		aFigureMats = writeMaterials( oNode );
		oDtuJson["Materials"].push( aFigureMats );
		oDtuJson['Morphs'] = s_aMorphExported;
		if (nChildren > 0){
			for ( var i = 0; i < nChildren; i++ ){
				var oChild = aChildren[ i ]; 
				aChildMats = writeMaterials( oChild );
				if ( aChildMats != false ){
					oDtuJson["Materials"].push( aChildMats );
				}		
			}
		};
		
		function combineMaterials( key, value ){
			var aNewMaterials = [];
			if( key == "Materials" ){
				for (var i=0; i < value.length; i++ ){
					var aNodeMats = value[i];
					for (var k=0; k < aNodeMats.length; k++ ){
						var aMat = aNodeMats[k];
						aNewMaterials.push( aMat );
					}
				}
				return aNewMaterials;
			}
			else{
				return value;
			}
		};

		oDtufile.open( DzFile.WriteOnly );
		oDtufile.write( JSON.stringify( oDtuJson, combineMaterials, 4 ) );
		oDtufile.close();
	};

	/*********************************************************************/	
	// Array : ...
	// Note: Cycle through all the Materials on a Node and return an array
	function writeMaterials( oNode )
	{	
		var oObj = oNode.getObject();
		if( oObj != null ){
			var oShape = oObj.getCurrentShape();
			var aMaterials = [];
			if( oShape ){
				for( var k = 0; k < oShape.getNumMaterials(); k++ ){
					var oMaterialInfo = {};
					var aProperties = [];
					var oMat = oShape.getMaterial( k );
					if( oMat ){	
						oMaterialInfo["Asset Name"] = oNode.name;
						oMaterialInfo["Asset Label"] = oNode.getLabel();
						oMaterialInfo["Material Name"] = oMat.getName();
						oMaterialInfo["Material Type"] = oMat.getMaterialName();
						
						// Get presentation and set material info
						var oPresentation = oNode.getPresentation();
						if( oPresentation != undefined ){
							var sPresentationType = oPresentation.type
							oMaterialInfo["Value"]  = sPresentationType;
						}
						else{
							oMaterialInfo["Value"]  = "Unknown";
						}

						// Load all the porperties info
						for( var i = 0; i < oMat.getNumProperties(); i++ ){
							var oProperty = oMat.getProperty( i );
							var oPropertyInfo = {};
							
							oPropertyInfo["Name"] = oProperty.getName();
							
							var bImageProperty = oProperty.inherits( "DzImageProperty" );
							var bColorProperty = oProperty.inherits( "DzColorProperty" );
							var bNumericProperty = oProperty.inherits( "DzNumericProperty" );

							if( bImageProperty ){
								var sTextureName = "";
								if(oProperty.getValue()){
									sTextureName = oProperty.getValue().getFilename();	
								}
								oPropertyInfo["Value"] = oMat.getDiffuseColor().name;
								oPropertyInfo["Data Type"] = "Texture";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bColorProperty ){
								var sName = oProperty.getName();
								var sTextureName ="";
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getColorValue().name;
								oPropertyInfo["Data Type"] = "Color";
								oPropertyInfo["Texture"] = sTextureName;
							}
							else if( bNumericProperty ){
								var sName = oProperty.getName();
								var sTextureName = "";
								if ( oProperty.getMapValue() ){
									sTextureName = oProperty.getMapValue().getFilename();
								}
								oPropertyInfo["Value"] = oProperty.getValue();
								oPropertyInfo["Data Type"] = "Double";
								oPropertyInfo["Texture"] = sTextureName;
							}
							aProperties.push( oPropertyInfo );
						}
						oMaterialInfo["Properties"] = aProperties;
						
						aMaterials.push( oMaterialInfo );
					}
				}						
			}
			return aMaterials
		}
		else{
			return false
		}
	};

	/*********************************************************************/
	// void : ...
	function main()
	{	
		prepareForExport();
		var sFileBasename;
		// Write data
		sFileBasename = String( "%1/%2" ).arg( s_sRootPath ).arg( s_sExports );
		var oNode = Scene.getPrimarySelection();
		replaceInstanceAll();
		buildMorphList( oNode );
		if( !promptMorphRules( oNode ) ){
			continue;
		}
		if( doesHavingSkeleton() ){
			if( !doesHavingHip() ){
				var aConvert = Scene.getSkeletonList();
				var nConvert = aConvert.length;
				if( nConvert > 0 ){
					var nResult = MessageBox.question(
						qsTr( "Some objects needs to be converted to props. Convert?\nThis operation is NOT undoable! (save first if needed)" ),
						s_sToolName, qsTr( "&Yes" ), qsTr( "&No" ) );
					if( nResult == 0 ){
						for( var i = 0; i < nConvert; i += 1 ){
							//debug( aConvert[i].getName() );
							try {
								convert2Prop( aConvert[i] )
							} catch( error ){}
						}
					}
				}
			}
		}
		exportScene( s_sExporter, s_sRootPath, s_sExports, s_sExportExt );
		savePropertiesToFile( s_sExporter, s_sRootPath, s_sExports, s_sExportExt );
		writeConfiguration( oNode, sFileBasename );
	};

	/*********************************************************************/
	main();
})();